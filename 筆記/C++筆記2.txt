類的聲明，}後面要加;。如class a{};。
在類的聲明裡同時進行聲明與定義的函數是inline函數。比如一些簡短的int getA(){return a;}。
類內聲明類外定義的函數加上inline也是inline函數。
類內變量與函數的聲明若未指定public之類，則都默認為private。
struct內也可以用private等修飾字。效果等同類。

---

類在構造時可以用:變量名(初始值)來初始化變量，稱為參數初始化表，如
book::book(char *a, double p):title(a),price(p){}
即在構造時進行title = a; price = p;。
參數初始化表的執行順序為變量在類內的聲明順序，比如:price(p),title(a)，則同樣是title = a先。

若類內有為初始化的const變量，則該變量只能用參數初始化表指定初始值，之後不能再修改。
如const int title;

類的構造函數的參數可以指定默認值，比如book::book(char *a, double p = 5.0){}
則p自動設為5.0。 /*注意，若同時存在book::book(char *a, double p){}，會報錯。*/

若想要制止book e;這樣的未經過構造函數的類生成。有兩種方法。
一是聲明一個默認構造函數以外的構造函數，這樣系統不會再自動生成默認構造函數。
二是將默認構造函數book(){}自己聲明在private使其無法訪問。

---

轉型構造函數
若在book類裡聲明一個public的 book(char* c){name = c;} 構造函數
那麼當有個函數fun(book r){}，只接收book類的參數，但我們又想要讓fun接收char[]類的參數時。
char n[10] = "fdsfsdf"; fun(n);
系統就會自動調用該轉型構造函數。

若要禁止調用，那麼在轉型構造函數的前面加上explicit修飾字即可。
如 explicit book(char* c){name = c;}

---

拷貝構造函數
有一個book e; 若要複製e成另一個w，那麼可以用拷貝構造函數和"="運算子重載。
拷貝構造函數一定要用引用如 book(book &b); book(const book &b); 不可book(book b);
因為規定不可以修改要複製的對象，而且傳遞實參的過程中也需要經過拷貝創造複製體，此為死循環。

拷貝構造函數允許有默認值。如 book(const book &b, price = 5.0);

若不自己定義拷貝構造函數和重載"="運算子，則系統會自動生成一個，默認是將所有值複製一遍。
問題是若類內有char* name[] 之類的指標，則所有複製出來的所有類裡面的name 都是指向同一個陣列。

故總結，若類內有包含指向動態分配記憶體的指針變量時，需要重新定義拷貝構造函數和重載"="運算子。

若要禁止拷貝行為，則可以聲明拷貝構造函數在private，如構造函數。
---

解構函數
~book(){}
調用的順序: 最後建構的實體的先調用解構子，最先建構的實體最後調用解構子。也就是倒序調用。

---

this指標
在類內的函數使用該指標，該指標指向該類自身。 該指標的值無法修改。 該指標只有在非static函數內才有效。

---

類的new和delete
可以用book e = new book(0, 32); 來new一個類。 這個行為會調用book的建構函數。
同樣用delete來銷毀一個類 delete e; 這個行為會調用book的解構函數。

但是malloc和free不會調用建構與解構函數。

---

類的const
類的const變量只能在參數初始化表裡修改。

類內的函數可以規定成不能修改類內的任何變量，只要在函數後面加上const。
如book::Show()const{}; 這樣的函數被稱為常成員函數。

類的實體在創造時可以加上const成為常對象，這樣該實體在調用函數時只能調用常成員函數。
且可以訪問，但不能修改成員變量。如cout << e.f;
如const book e(0, 32); 或 book const e(0, 32);

若是想要修改const對象裡的非const成員變量，可以在想要修改的變量前面加上mutable修飾字，
如 mutable int f; 這樣就可以訪問並修改，而且類的const函數也可以修改該變量。

類內的函數，其參數可以加上const，避免對其造成修改。如 book::Show(const int &a){};

---

類的static
類內透過static修飾字聲明的變量，被所有實體共享。 如static int d;
類內的靜態成員變量，不管是private、public或protected，都必需在類外定義與初始化，如
class book{static int d;};
int book::d = 0;
若靜態成員變量未在類外初始化，有些編譯器會默認初始化為0，有些則出現未知行為。
被聲明為靜態變量的成員，不占用實體的空間。也就是sizeof()時，不會將靜態成員變量算進去。

函數聲明時加上static，如class book{ static Show(){}; }; 該函數及靜態成員函數。
類內靜態成員函數只能訪問靜態成員變量，若訪問非static變量會報錯。
呼叫靜態成員函數可以透過實體，或是直接用域名訪問，如book::Show();
靜態成員函數裡沒有this指標。 靜態成員函數裡聲明的靜態變量同樣被所有實體共享。

---

friend
若一個A類的函數需要訪問另一個B類的private成員，那麼B類可以透過聲明這個A類的函數為friend函數，
藉此允許該函數來直接訪問B類的private成員。不然只能透過B類的public函數做為媒介來訪問。如
class book;
class man{
public:
 	void readname(book &b){
	cout << b.name; //要訪問b的private變量name。
	}
}; 
class book{
piblic:
 	friend man::readname(book &b); //允許man類的readme函數訪問自己的private變量
private:
 	char* name;
};
/*注意，要聲明為friend的函數必須放在friend聲明上方，不然man::readname的man會讀取不到。
且book類也要在man上方先聲明，不然readname()的book參數會讀取不到，會報錯。*/
可以定義多個類的函數為自己類的friend函數。

或是直接將整個類聲明為friend，如 friend man; 但注意同樣要先聲明class man在上方。
這樣man類裡的所有函數都是friend函數。 friend是單向的，也就是man不可以訪問book的private變量。
friend關係不可以傳遞，也就是A是B的friend、B是C的friend，但A不是C的friend。