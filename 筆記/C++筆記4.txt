virtual是多態的實現方法之一

在類的繼承關係裡面，函數的覆寫一般來說是沒問題的。
但是在使用類的指標時就會有問題。即執行期繫節的問題。

比如，B繼承於A，覆寫了A的show()。普通的使用B.show()是沒問題的。
但是若有個指向A類的指標pA，現在將其指向一個B類。(父類的指標可以指向子類，反之卻不行。)
現在使用pA->show()，用出來的卻是未經過覆寫的，A類的show()。

解決方法:
在宣告A類時，在show()前加上virtual修飾字，如 virtual void show()
這樣使用pA的show()時就是B類的show()了。

只要在宣告類時加virtual即可，實作類時不需要。

宣告B類時，在show()前，virtual可加可不加。
而且B類的子類C也可以享有同樣效果，即一次virtual，底下子類皆受益。

---

多態的背後原理
當一個類內的函數有virtual修飾字時，他與他的所有子類都會獲得一個vtable，(虛成員函式表)
這個虛成員函式表紀錄了該類的所有虛成員函式的地址，之後C++便透過該地址訪問。
vtable的首地址會被放在類實體的最前面，占用4bit的空間(32位元OS)。

---

虛解構函數
在以指針方式使用類時，要注意解構函數內是否有"分配動態記憶體"的操作。
若有，則須在宣告解構函式時加上virtual修飾字。 (只需要在最上層的基類宣告，下層就全部有效)
A* p = new C;
delete p;
否則在delete p; 時，(p是指向類的指針)，只會執行A的解構函數
(若p是B*，則執行A與B)。(即指執行p所指向的類的解構函數)
---

靜態(static)成員函式不可以加上virtual修飾字。

---

覆蓋
B類繼承於A類，兩類的成員皆有一個virtual func(){}，則從B類使用func時，會使用到B類的func。
即B類的func覆蓋了A類的func。
若是藉由指針來操作，則會形成多態。

遮蔽
同樣B繼承於A，若A成員僅有一func()，B成員僅有一func(int a)，則無法使用B.func()。
若要從B使用A的func，需要加上A::域名，如B.A::func()。或B->A::func()。
即只要函式同名，就會遮蔽。

---

純虛成員函式
在虛函式後面去掉定義，加上 = 0，如
class A{ virtual void func() = 0; };
這樣，該func就是純虛成員函式，並且A類也會成為抽象類，無法創建實體類(如a = new A;)
抽象類是用來繼承的，只要繼承時有將所有純虛成員函式定義好，就可以創建實體。
相對的，若是沒將所有純虛成員函式定義好，則該子類同樣會是抽象類。

---

dynamic_cast
B類繼承於A類，且兩者皆有虛函式。若有一指針原先指向A類，要將其安全的指向B類，則可使用該指令。
dynamic_cast<指定型別的指標>(某類的指標) ，會回傳一個強制轉成指定型別的，指向某類的指標。
如pA = dynamic_cast<B*>(pA) ，代表要將pA從A*變成B*。
或者也可以在其中new一個新類，如pA = dynamic_cast<B*>(new A);
若轉換失敗會傳回0，非強制轉型，因此是安全的。

父類指針不可轉成子類，A類不可轉成B類。
無繼承關係，或者沒有虛函式，則不可用。

---

typeid
這是一個操作符，用法:
int a;
if( typeid(a) == typeid(int) )
	return true;
若是類別的指針，則要確認是否有多態性(virtual things)。
若有多態性，則typeid(*p)會以運行期，p實際所指向的東西來判斷。B與A有繼承關係。
如A* p = B，則typeid(*p)是B類。typeid
若無多態性，則不管什麼時期，p指向什麼類，都以p宣告時的類為主。
如 A* p = B; typeid(*p)仍是是A類。
不管有無多態，typeid(p)都是宣告時的類，即A類。