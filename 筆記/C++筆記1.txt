引用 reference
int & func(){return a;}
宣告為int&，則傳回a的引用。不複製，不經過暫存空間，速度快。但是return值不可以是運算式。
但是，若傳回的引用變數壽命只有在fun內(比如傳回在fun內宣告的b)，則會報錯。
因此建議int& fun(int& a){return a;} 即傳回原本就是引用自外地的變數。

---
static int a; //宣告在函數與類(總之就是大括號)外面。這樣a只會在他所處的cpp或h檔裡看見並使用。
---
a = static_cast<型別>(變數); 可以強制轉型
---
const int* p = NULL;
p = const_cast<int*>(p); 可以消除該指針的const屬性，使其可以重新指向非const變數
/*無奈之舉，盡量別用*/
---
int *at; 真，強制轉型。直接一個bit一個bit的移過去。/*危險*/
double *d = reinterpret_cast<double *>(a);
---
decltype
用法， decltype(A) B;
若A是int，則相當於宣告 int B; ，即參照A的型別來宣告B。
A也可以是一個函式，如double func()，透過decltype(func()) B;，來使B為double。
其他規則頗複雜，需查wiki。
---
typeid
這是一個操作符，用法為typeid(A)，會傳回A的型別。該傳回值的型別是typeinfo類，一個系統定義的類。
A也可以直接是int, float, double等。基本用法為int a; if( typeid(a) == typeid(float) ){}

若用在指向類的指標上(普通指標同上)，則要注意宣告時所指向的類是否為多態(有virtual成員)。
如A* p = &B; typeid(p)是A，typeid(*p)還是A。這是沒多態時，採用編譯期計算。
若有多態，則typeid(*p)是B，會直接找到p所指向的類並判斷。
---

inline函數
inline int fun(){retuen a;} 
inline擺在型別前面。而且一定要配函數主體(大括號)，若只在上排宣告時使用則無用。

---

new和delete
new配delete。 new int[10]配delete[]。 不要和malloc之類混和使用。
int *a = new int; delete a;
int *a = new int[10]; delete[] a;

---

try和catch
try{throw 5;}catch(int error){}。兩者間可以不相連。
throw 值;  執行到這裡就跳到catch，之後catch接值並執行{內容}
/*若是在try裡使用先前提到的new，若分配記憶體失敗，new會自己throw。要接收這個throw，要使用
catch(std::bad_alloc){cout <<"失敗";}。*//*未知std::bad_alloc是否可檢測*/

---

explicit
explicit(顯性)，implicit(隱性)。
轉型別時，有顯隱之分。如，一類名INT，內有多成員，且定義一建構函數 INT(int i){data = i;}。
則宣告 INT I = 10; 時，會自動呼叫該建構函數。此乃隱性(implicit)轉型(type cast)。
若不想要隱性轉型，則可在指定建構式前加上explicit修飾字。如 implicit INT(int i){data = 1;}。
這樣，若要使用該建構式，則一定要利用INT i(10);形式來使用。(編譯器會檢查)

---

using
取代typedef的東西(C++11以上)
using FP = void (*) (int, const int);  ，等價於 typedef void (*FP) (int, const int);

using可以配上template來使用，例
template <typename T>
using Vec = MyVector<T, MyAlloc<T>>;

定義之後使用方法如下
Vec<int> vec;