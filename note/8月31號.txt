GUI的模式:
不可以直接使用GUI元件或組件，必須透過window。window是一種結構體(非類別)，裡面裝著自身所占區域rect，
還有放在其中GUI元件的operation函式、以及各種資料的指標。
window有覆蓋層級，是一個int序號，每當新的一個window出現，則將其序號設為0，前一個設為1，以此類推遞增
，因為新出現的window必然覆蓋前面出現的window，這樣在判斷熱點時就不會有點到被window覆蓋的按鈕的蠢事。
用來判斷熱點在哪個window，具體code如下

int count = 10; //當前存在的window數
int hot = 0; //熱點所在的window序號
for(int i = 0; i < count; i++){ 
	//從序號為0的window一個個查看，看滑鼠是否在裡面
	//windows是一個指標陣列，放著指向所有存在的window的指標。
	if( isMouseInRect(windows[i]->rect) == true){
		hot = i;
		break; //若在裡面，則設定熱點為該window，並跳出。
	}
}
... //進入該window，執行其中的GUI元件

因為一個window裡包含的GUI元件，數量是不固定的。所以window結構體使用假指標來間接連結GUI元件，算是一個
interface，至於具體GUI元件則在其他地方宣告。
假指標的使用前提是，每個GUI元件都有自己的int序號。
window結構體範例如下

struct{
	sdl_Rect rect;
	int number; //這是window的序號
	int ItemNumber[100]; //一個window最多存放一百個元件或組件。
}

GUI與繪圖類的連結:
GUIdraw獨立於主要繪圖類之外，這樣不方便調控fps，不方便一起控制。但是GUI類和主要繪圖類是同意等級的存
在，不應該互相include，所以應該要有個中介層。比如一個儲存GUI要顯示的東西的結構，主要繪圖類讀取這個結
構並顯示，這個結構應該有數個元件的資料(rect、texture等)。
這是個好方法，但是或許可以再延伸。
在GUI與主要繪圖類上方再加一個更高等級的抽象層，include兩者，並使用兩者提供的介面，資料則由這個抽象
層自己保留並使用。比如這個抽象層自己保存GUI元件的資料，再傳給主要繪圖類draw。這又可以引申出，這個抽
像介面可以include更多模塊再使用，相當於把sdl又包裝一遍，是否太雞婆?