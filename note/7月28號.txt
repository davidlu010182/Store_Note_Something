全局
引擎雙巨頭(gDisplay, GUI)基礎架構完成，兩者都include了gInit.h，並從那媕簳gMainSurface等重要全局物資的定義。
基於還不了解pragma once以及如何實現其功能，兩個分屬不同cpp的物件要如何溝通，這方面會有限制。
目前的想法是完整規劃出嚴謹的上下級關係樹(誰include誰，由gInit開始到雙巨頭，再到雙巨頭手底下，以此形成一棵樹)。
並且做好嚴格的封裝(雖然這樣可能會減少一點運行效率)，但這是必要的。

gDisplay
在原先的設計中，架構很簡潔明瞭，就是提供gMainSurface給其他的Display當畫布塗，不管塗得怎樣，反正texture -> render上去就對了
但是後來又加上了timer來管理FPS，在cpp最上方有個define來規定要取幾次FPS來做平均(名字可能取的太長了)
目前只有FPS的管理需要注意，但是到GameCore的時候就要考慮動畫的問題
圖片素材如何顯示，若圖片精靈數少於規定怎麼辦，碰撞如何處理又如何反饋至其他函數
考慮用它來管理所有的繪製

GUI
架構同樣簡潔明瞭，就是接收所有操作，然後提供給Situation去進行動作(基本的底層的東西自己呼叫)
在弄好GUIDisplay和GUISituation之後，要負責管理(在init註冊、提供呼叫等等)
目前最大的問題是滑鼠滾輪的問題。
因為在沒有任何事件產生的時候(滑鼠沒動)，event不會變，代表上一次的操作會留存到下一禎的檢查
也就是說，不能像chorme一樣，鼠標不動，單靠滾輪移動。
若是這樣，那麼event.wheel.y會持續處在1/-1的狀態，會判定為一直在滾，直到下一個event產生(motion之類)
解決辦法：做一個wheel事件專用的抑止器函數(去重置為零)，並在合適的地方放置(每一禎的最後)
若有其他案件同樣如此，也可以考慮用同個函數抑止
還有
鍵盤的選擇，需要自己再弄一個map(一個struct，裝著對應的keycode)，這樣就可以讓玩家自己調鍵盤對應布局，比如up對w之類
並且operate的條件要改成檢查keyboard map struct

gInit
目前大致架構就是這樣了，但是處在include關係樹的上層，各種方面都要小心謹慎。
但是loadConfig要實現，還要弄一個ConfigFile給他讀取...程式碼可能會膨脹到可怕的地步，要想想怎麼處理
ConfigFile格式，考慮用xml或像上古卷軸那樣的純文字檔or其他

gEnd
有點雞肋，就負責全局的destroy或free吧，但是又管不到雙巨頭手下的成員...
但是還是有它的意義在，可能...讓雙巨頭手下的成員include他，然後考慮弄個橋樑把雙巨頭手下需要free的東西給他吧
要不然就是整合進gInit裡面

gDisplay
實作按鈕滑條等，就是個函數庫。
把按鈕滑條先弄到GUISurface，之後再放到gMainSurface上去，這樣就可以自己調控GUI的透明度等
還有，要有能夠載入圖片的功能，這樣就能弄出GUI的紋理
第二想法
或許可以下轄GUISituationDisplay類，具體實現就取每個Situation的surface來用
應該在GUISituation下方

Text
因為每次要使用時，可能需要的的字體以及字體大小都不同的關係，目前的想法是弄一個可以被繼承的類。
顯示方法有大塊段落以及一小段文字，外頭看來就是直接拿到有字的surface，之後可能要考慮ColorKey
在gConfig裡面有字體設定，目前想法是用enum依據功能列舉字體，這樣在載入字體時就不用費力打出檔名了
一樣可以用loadConfig調整
目前只有Blended，之後可以考慮弄個shaded版本之類

方向：
先把GUI的display搞定
再把GUI的Situation搞定
GUI，即操作搞定
GameCore架構
gDisplay搞定

待辦：
Text搞好
學習物件導向(完整)
gConfig的keyboard做好做滿
寫一個gConfigFile
製作一個gWindow類專門處理視窗事件(放大縮小之類)，考慮給gDisplay管
做一個wheel事件專用的抑止器函數
GUI，弄一個struct來mapping鍵盤，並且改掉operate的檢查調件至該struct
實作GUIDisplay，要有能夠載入圖片的功能
思考如何弄動畫
架構起GameCore
